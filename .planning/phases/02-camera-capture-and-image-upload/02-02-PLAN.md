---
phase: 02-camera-capture-and-image-upload
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - mobile/src/screens/Camera/CameraScreen.tsx
  - mobile/src/screens/Camera/PhotoReviewScreen.tsx
  - mobile/src/components/Camera/ShutterButton.tsx
  - mobile/src/components/Camera/FlashToggle.tsx
  - mobile/src/components/Camera/CameraSwitcher.tsx
  - mobile/src/components/Camera/IrisGuideOverlay.tsx
  - mobile/src/components/Camera/CaptureHint.tsx
  - mobile/src/hooks/useCamera.ts
  - mobile/src/hooks/useUpload.ts
  - mobile/src/services/upload.ts
  - mobile/src/services/consent.ts
  - mobile/src/navigation/RootNavigator.tsx
autonomous: true

must_haves:
  truths:
    - "User can open camera viewfinder with full-screen preview and circular iris guide overlay"
    - "User can toggle flash (on/off), switch front/back camera, and pinch-to-zoom"
    - "User sees static tip text before first capture: 'Hold phone 10-15cm from eye, ensure good lighting'"
    - "Tapping shutter captures a photo and navigates to review screen showing the captured image"
    - "Review screen has Retake and Accept buttons -- Retake returns to camera, Accept triggers upload"
    - "After Accept, user navigates to gallery and sees progress bar on the photo thumbnail during upload"
    - "Upload retries silently up to 3 times with exponential backoff (1s, 2s, 4s) on failure"
    - "If all retries fail, photo thumbnail shows error state with manual Retry button"
    - "Biometric consent is checked before showing camera -- user who hasn't consented sees consent screen first"
  artifacts:
    - path: "mobile/src/screens/Camera/CameraScreen.tsx"
      provides: "Full-screen Vision Camera viewfinder with circular guide overlay, camera controls, and shutter button"
      min_lines: 80
    - path: "mobile/src/screens/Camera/PhotoReviewScreen.tsx"
      provides: "Full-screen captured photo display with Retake and Accept buttons"
      min_lines: 40
    - path: "mobile/src/hooks/useCamera.ts"
      provides: "Camera device selection, flash state, zoom control, permission checks"
      min_lines: 30
    - path: "mobile/src/hooks/useUpload.ts"
      provides: "Upload queue with progress tracking, retry logic, and error state"
      min_lines: 50
    - path: "mobile/src/services/upload.ts"
      provides: "Presigned URL upload to S3 with progress callback and exponential backoff retry"
      min_lines: 40
    - path: "mobile/src/services/consent.ts"
      provides: "Biometric consent check and grant flow using Phase 1 privacy API"
      min_lines: 30
    - path: "mobile/src/components/Camera/IrisGuideOverlay.tsx"
      provides: "Semi-transparent overlay with circular cutout for iris framing guidance"
      min_lines: 20
  key_links:
    - from: "mobile/src/screens/Camera/PhotoReviewScreen.tsx"
      to: "mobile/src/hooks/useUpload.ts"
      via: "Accept button triggers upload, navigates to gallery with upload in progress"
      pattern: "uploadPhoto|startUpload"
    - from: "mobile/src/services/upload.ts"
      to: "backend/app/api/routes/photos.py"
      via: "POST /photos/upload for presigned URL, PUT to S3, POST /photos/{id}/confirm"
      pattern: "api/v1/photos"
    - from: "mobile/src/screens/Camera/CameraScreen.tsx"
      to: "mobile/src/services/consent.ts"
      via: "Check biometric consent on mount, redirect to consent screen if not granted"
      pattern: "biometric.*consent|checkConsent"
---

<objective>
Implement the iris camera capture experience with Vision Camera and the full upload pipeline. Users can capture iris photos with camera controls, review and accept them, and photos upload to S3 with visible progress and automatic retry.

Purpose: This is the core capture-to-upload flow -- the primary user interaction for Phase 2. The camera must be optimized for iris photography (close-up, high quality) and the upload must be reliable with clear progress feedback.

Output:
- Full-screen camera viewfinder with circular iris guide overlay
- Camera controls: shutter button, flash toggle, front/back switch, pinch-to-zoom
- Photo review screen with Retake/Accept flow
- Upload service: presigned URL -> S3 PUT with progress -> confirm
- Biometric consent gate before camera access
</objective>

<execution_context>
@/home/jbellot/.claude/get-shit-done/workflows/execute-plan.md
@/home/jbellot/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-camera-capture-and-image-upload/02-CONTEXT.md
@.planning/phases/02-camera-capture-and-image-upload/02-RESEARCH.md

# Prior plan in this phase (must exist before this plan runs)
@.planning/phases/02-camera-capture-and-image-upload/02-01-SUMMARY.md

# Key mobile files from Plan 01
@mobile/src/navigation/RootNavigator.tsx
@mobile/src/navigation/types.ts
@mobile/src/services/api.ts
@mobile/src/store/authStore.ts
@mobile/src/store/uiStore.ts
@mobile/src/types/photo.ts
@mobile/src/utils/permissions.ts
@mobile/src/utils/constants.ts

# Backend endpoints this plan integrates with
@backend/app/api/routes/photos.py
@backend/app/api/routes/privacy.py
@backend/app/schemas/photo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement camera viewfinder with Vision Camera, controls, and iris guide overlay</name>
  <files>
    mobile/src/screens/Camera/CameraScreen.tsx
    mobile/src/components/Camera/ShutterButton.tsx
    mobile/src/components/Camera/FlashToggle.tsx
    mobile/src/components/Camera/CameraSwitcher.tsx
    mobile/src/components/Camera/IrisGuideOverlay.tsx
    mobile/src/components/Camera/CaptureHint.tsx
    mobile/src/hooks/useCamera.ts
    mobile/src/services/consent.ts
    mobile/src/navigation/RootNavigator.tsx
  </files>
  <action>
    **Step 1: Create biometric consent service**
    Create `src/services/consent.ts`:
    - `checkBiometricConsent()`: GET /api/v1/privacy/consent/biometric-status -> returns {has_consent: boolean}
    - `getJurisdictionInfo(countryCode?, stateCode?)`: GET /api/v1/privacy/jurisdiction -> returns ConsentRequirements with jurisdiction-specific text
    - `grantBiometricConsent(jurisdiction, consentTextVersion)`: POST /api/v1/privacy/consent with {consent_type: "biometric_capture", jurisdiction, consent_text_version}

    **Step 2: Create useCamera hook**
    Create `src/hooks/useCamera.ts`:
    ```typescript
    export function useCamera() {
      const [cameraPosition, setCameraPosition] = useState<'back' | 'front'>('back');
      const [flash, setFlash] = useState<'off' | 'on'>('off');
      const zoom = useSharedValue(1); // Reanimated shared value for smooth zoom
      const device = useCameraDevice(cameraPosition);

      const toggleFlash = () => setFlash(f => f === 'off' ? 'on' : 'off');
      const toggleCamera = () => setCameraPosition(p => p === 'back' ? 'front' : 'back');

      // Min/max zoom from device capabilities
      const minZoom = device?.minZoom ?? 1;
      const maxZoom = Math.min(device?.maxZoom ?? 1, 10); // Cap at 10x for usability

      return { device, cameraPosition, flash, zoom, minZoom, maxZoom, toggleFlash, toggleCamera };
    }
    ```

    **Step 3: Create camera control components**
    - `ShutterButton.tsx`: Large circular white button (70px) with pressable animation. On press, calls `onCapture` prop. Disable while capturing (prevent double-tap). Use Pressable with opacity feedback.

    - `FlashToggle.tsx`: Flash icon button (bolt icon or text "Flash"). Toggles between on/off. Shows current state visually (highlighted when on). Position: top-right of camera view.

    - `CameraSwitcher.tsx`: Camera flip icon button. Toggles front/back. Position: top-left or bottom alongside shutter. Use a flip camera icon (or text label).

    - `IrisGuideOverlay.tsx`: **Research recommendation: full-screen camera with circular guide overlay.** Create a semi-transparent dark overlay covering the full screen with a circular cutout in the center (about 60% of screen width). The cutout helps users frame their iris. Implementation: Use a View with absolute positioning, dark background (rgba 0,0,0,0.4)), and a circular transparent hole. Can be done with SVG (react-native-svg) or a creative View arrangement. Simplest approach: Four rectangles around a center circle, or use a single View with borderRadius and overflow hidden. Keep it simple -- a thin white/light circle outline (3px) centered on screen is sufficient and performs well.

    - `CaptureHint.tsx`: Static text banner shown at top of camera screen: "Hold phone 10-15cm from eye. Ensure good lighting." with a small eye icon. Semi-transparent dark background. Dismisses after first capture or after 5 seconds (whichever comes first).

    **Step 4: Implement CameraScreen**
    Create `src/screens/Camera/CameraScreen.tsx`:

    1. **Biometric consent check on mount:**
       - Call `checkBiometricConsent()`. If `has_consent: false`:
         - Show inline consent flow (modal or full-screen overlay):
           - Fetch jurisdiction info via `getJurisdictionInfo()`
           - Display consent text with scrollable view
           - "I agree" checkbox + "Grant Consent" button
           - On grant: call `grantBiometricConsent()`, then proceed to camera
         - If user declines: navigate back to gallery

    2. **Camera permission check:**
       - Use `checkCameraPermission()` from utils/permissions.ts
       - If DENIED: call `requestCameraPermission()` (system dialog appears)
       - If BLOCKED: Show screen with explanation + "Open Settings" button (using Linking.openSettings()) and a "Back to Gallery" button (fallback mode)
       - If GRANTED: proceed to camera rendering

    3. **Camera rendering:**
       - Full-screen Vision Camera component using device from useCamera hook
       - Pass `photo={true}`, `photoQualityBalance="quality"`, `isActive={true}`
       - Wrap Camera in `<GestureDetector>` with pinch gesture for zoom:
         ```typescript
         const pinchGesture = Gesture.Pinch()
           .onUpdate((e) => {
             zoom.value = Math.max(minZoom, Math.min(e.scale * startZoom, maxZoom));
           })
           .onEnd(() => {
             startZoom = zoom.value;
           });
         ```
       - Use `Animated.createAnimatedComponent(Camera)` with `useAnimatedProps` for smooth zoom
       - Render IrisGuideOverlay on top of camera
       - Render CaptureHint at top
       - Render camera controls at bottom: CameraSwitcher (left), ShutterButton (center), FlashToggle (right)

    4. **Photo capture:**
       - ShutterButton onPress calls `camera.current.takePhoto({ flash: flashMode, enableShutterSound: true })`
       - Wait for camera.current to be initialized before enabling shutter (check ref !== null AND device !== null)
       - On successful capture: navigate to PhotoReview screen with `{ photoPath: photo.path, photoWidth: photo.width, photoHeight: photo.height }`

    **Step 5: Update navigation**
    Update `RootNavigator.tsx` to add PhotoReview screen to MainStack. Ensure Camera -> PhotoReview navigation is properly typed.

    **IMPORTANT NOTES:**
    - Use `react-native-reanimated` for zoom animation (UI thread, 60fps). Do NOT use React state for zoom.
    - Check device !== null before rendering Camera component (show loading indicator if null)
    - `photoQualityBalance="quality"` prioritizes image quality over capture speed (critical for iris detail)
    - Camera `isActive` should be false when screen is not focused (use `useIsFocused()` from React Navigation)
    - Do NOT add image compression -- photos upload at full resolution per CONTEXT decision
  </action>
  <verify>
    1. `cd mobile && npx tsc --noEmit` passes TypeScript compilation
    2. All camera component files exist: `ls src/components/Camera/`
    3. CameraScreen.tsx imports and uses Vision Camera, Reanimated, Gesture Handler
    4. useCamera hook provides device, flash, zoom, toggle functions
    5. Consent service correctly calls Phase 1 privacy endpoints
    6. IrisGuideOverlay renders a circular guide element
    7. CaptureHint shows static tip text
  </verify>
  <done>
    - CameraScreen renders full-screen Vision Camera with circular iris guide overlay
    - Camera controls work: shutter button, flash toggle (on/off), front/back camera switch
    - Pinch-to-zoom works with smooth Reanimated animation
    - Static capture hint displays "Hold phone 10-15cm from eye, ensure good lighting"
    - Biometric consent checked on camera open, consent flow shown if not yet granted
    - Camera permission handled: request on first use, show settings link if blocked
    - Photo capture navigates to PhotoReview with photo path
    - Camera deactivates when screen loses focus (performance optimization)
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement photo review screen and upload pipeline with progress and retry</name>
  <files>
    mobile/src/screens/Camera/PhotoReviewScreen.tsx
    mobile/src/hooks/useUpload.ts
    mobile/src/services/upload.ts
  </files>
  <action>
    **Step 1: Create upload service**
    Create `src/services/upload.ts`:

    ```typescript
    interface UploadResult {
      photoId: string;
      success: boolean;
      error?: string;
    }

    interface UploadCallbacks {
      onProgress: (percent: number) => void;
      onComplete: (result: UploadResult) => void;
      onError: (error: string) => void;
    }

    async function uploadPhoto(
      photoPath: string,
      callbacks: UploadCallbacks,
      maxRetries: number = 3
    ): Promise<UploadResult> {
      // Step 1: Request presigned URL from backend
      const { data: presignData } = await api.post('/photos/upload', {
        content_type: 'image/jpeg',
      });
      const { upload_url, photo_id, s3_key } = presignData;

      // Step 2: Upload to S3 with progress tracking and retry
      let attempt = 0;
      while (attempt < maxRetries) {
        try {
          // Read file as blob from local path
          const fileResponse = await fetch(`file://${photoPath}`);
          const blob = await fileResponse.blob();

          await axios.put(upload_url, blob, {
            headers: { 'Content-Type': 'image/jpeg' },
            onUploadProgress: (progressEvent) => {
              const percent = Math.round(
                (progressEvent.loaded / (progressEvent.total || 1)) * 100
              );
              callbacks.onProgress(percent);
            },
          });

          // Step 3: Confirm upload with backend
          // Get file info from the photo (width, height from capture metadata, size from blob)
          await api.post(`/photos/${photo_id}/confirm`, {
            file_size: blob.size,
          });

          callbacks.onComplete({ photoId: photo_id, success: true });
          return { photoId: photo_id, success: true };

        } catch (error) {
          attempt++;
          if (attempt >= maxRetries) {
            const errorMsg = 'Upload failed after retries';
            callbacks.onError(errorMsg);
            return { photoId: photo_id, success: false, error: errorMsg };
          }
          // Exponential backoff: 1s, 2s, 4s
          await new Promise(resolve =>
            setTimeout(resolve, 1000 * Math.pow(2, attempt - 1))
          );
        }
      }
    }
    ```

    **Key details:**
    - Use axios for S3 PUT (not the api instance -- presigned URLs go directly to S3, not through backend)
    - Use the configured api instance (with JWT) only for backend calls (/photos/upload, /photos/{id}/confirm)
    - Retry ONLY on network errors and 5xx. Do NOT retry on 4xx (bad request, auth failure)
    - Exponential backoff: 1s, 2s, 4s between retries
    - File read: `fetch('file://' + photoPath)` to get a blob from the local camera capture path
    - Width/height come from the Vision Camera photo result (passed as params), not from reading the blob

    **Step 2: Create useUpload hook**
    Create `src/hooks/useUpload.ts`:

    A zustand-based or stateful hook that manages an upload queue:
    ```typescript
    interface UploadItem {
      id: string; // local unique ID
      photoPath: string;
      photoId?: string; // backend photo ID (set after presign)
      progress: number; // 0-100
      status: 'uploading' | 'completed' | 'failed';
      error?: string;
      width?: number;
      height?: number;
    }

    function useUpload() {
      const [uploads, setUploads] = useState<Map<string, UploadItem>>(new Map());

      const startUpload = (photoPath: string, width?: number, height?: number) => {
        const localId = uuid(); // generate local ID
        // Add to uploads map with status='uploading', progress=0
        // Call uploadPhoto() with callbacks that update the map entry
        // On progress: update progress percentage
        // On complete: set status='completed', invalidate React Query photos cache
        // On error: set status='failed' with error message
      };

      const retryUpload = (localId: string) => {
        // Get upload item, reset status to 'uploading', progress to 0
        // Re-call uploadPhoto()
      };

      const getUploadForPhoto = (photoId: string) => {
        // Find upload item by backend photo ID
      };

      return { uploads, startUpload, retryUpload, getUploadForPhoto };
    }
    ```

    Use React Query's `queryClient.invalidateQueries({ queryKey: ['photos'] })` on upload complete to refresh the gallery.

    Make `useUpload` available globally -- either via Zustand store or React Context at App level -- so the gallery screen can read upload progress for thumbnails.

    **Step 3: Create PhotoReviewScreen**
    Create `src/screens/Camera/PhotoReviewScreen.tsx`:

    - Receives `photoPath`, `photoWidth`, `photoHeight` from navigation params
    - Displays the captured photo full-screen using `<Image source={{ uri: 'file://' + photoPath }}>`
    - Bottom bar with two buttons:
      - **Retake** (left): Navigates back to CameraScreen (pops this screen)
      - **Accept** (right, primary/highlighted): Triggers upload and navigates to gallery

    - **Accept flow:**
      1. Call `startUpload(photoPath, photoWidth, photoHeight)` from useUpload hook
      2. Immediately navigate to Gallery screen (`navigation.navigate('Gallery')` or `navigation.popToTop()`)
      3. The upload runs in the background while user sees the gallery
      4. Gallery shows a new thumbnail for the uploading photo with a progress bar overlay (implemented in Plan 03)

    - Clean, minimal UI: photo fills screen, buttons at bottom with safe area padding
    - No cropping or editing in Phase 2

    **Step 4: Wire PhotoReview into navigation**
    Ensure PhotoReviewScreen is in MainStack navigation with correct params typing. Camera -> PhotoReview -> Gallery flow should work.

    **IMPORTANT NOTES:**
    - After Accept, navigate to Gallery immediately (do not wait for upload). User sees progress on the thumbnail.
    - The useUpload hook state persists in memory while the app is open. If app is killed during upload, the photo is lost (acceptable for Phase 2; background upload is a future enhancement).
    - Use a separate axios instance (no JWT interceptor) for the presigned S3 PUT -- the presigned URL includes auth in the query string.
    - Photo path from Vision Camera is a file:// URI on iOS and a content:// or file:// URI on Android. Test both.
    - Photo dimensions (width, height) are available from the Vision Camera takePhoto() result.
  </action>
  <verify>
    1. `cd mobile && npx tsc --noEmit` passes TypeScript compilation
    2. PhotoReviewScreen shows captured photo with Retake and Accept buttons
    3. Upload service correctly: (a) requests presigned URL from backend, (b) PUTs to S3, (c) confirms with backend
    4. Retry logic: if S3 PUT fails, waits with exponential backoff and retries up to 3 times
    5. useUpload hook tracks progress (0-100%) and status (uploading/completed/failed)
    6. Accept navigates to Gallery immediately, upload continues in background
    7. On upload complete, React Query photos cache is invalidated (gallery will refresh)
  </verify>
  <done>
    - PhotoReviewScreen displays captured iris photo full-screen
    - Retake button returns to camera, Accept button starts upload and navigates to gallery
    - Upload service requests presigned URL, PUTs to S3 with progress tracking, confirms with backend
    - Exponential backoff retry (1s, 2s, 4s) on upload failure, up to 3 attempts
    - useUpload hook provides per-photo progress percentage and status
    - Upload state available globally for gallery to display progress overlay
    - React Query cache invalidated on upload complete to refresh gallery
    - Full capture flow works: Camera -> take photo -> Review -> Accept -> Gallery (upload in background)
  </done>
</task>

</tasks>

<verification>
1. Full capture flow works end-to-end: open camera -> frame iris -> tap shutter -> review photo -> tap Accept -> see gallery with uploading photo
2. Camera controls functional: flash toggles, camera switches front/back, pinch-to-zoom smooth
3. Biometric consent gate: first camera open checks consent, shows consent flow if needed
4. Camera permission handled: request dialog shown, blocked state shows settings link
5. Upload completes: presigned URL obtained, S3 PUT succeeds, backend confirms
6. Retry works: interrupt network -> upload retries silently -> completes on reconnect (or shows error after 3 attempts)
7. TypeScript compiles without errors
</verification>

<success_criteria>
- Full-screen Vision Camera viewfinder with circular iris guide overlay renders correctly
- All camera controls work: shutter, flash, front/back switch, pinch-to-zoom
- Photo capture produces full-resolution image navigated to review screen
- Review screen Retake/Accept flow works as expected
- Upload pipeline: presigned URL -> S3 PUT with progress -> backend confirm
- Retry with exponential backoff (3 attempts, 1s/2s/4s)
- Upload runs in background after Accept, user sees gallery immediately
- Biometric consent checked before camera access
</success_criteria>

<output>
After completion, create `.planning/phases/02-camera-capture-and-image-upload/02-02-SUMMARY.md`
</output>
