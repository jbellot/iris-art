---
phase: 07-polish-and-production-readiness
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - backend/docker-compose.production.yml
  - backend/app/core/config.py
  - backend/app/storage/s3.py
  - backend/.env.production.example
  - mobile/ios/IrisArt/PrivacyInfo.xcprivacy
  - mobile/ios/IrisArt/Info.plist
  - mobile/android/app/build.gradle
  - mobile/android/app/src/main/AndroidManifest.xml
  - mobile/android/gradle.properties
autonomous: true

must_haves:
  truths:
    - "Production Docker Compose runs the full stack (web, celery, postgres, redis, minio) behind Traefik reverse proxy with HTTPS"
    - "Image URLs served to mobile use CDN-compatible paths (CloudFront origin for MinIO) instead of direct MinIO URLs"
    - "PrivacyInfo.xcprivacy declares all collected data types (photos, biometric data) for App Store review"
    - "Android release build is configured with signing and ProGuard for Play Store submission"
    - "Production environment template documents all required environment variables for deployment"
  artifacts:
    - path: "backend/docker-compose.production.yml"
      provides: "Production deployment stack with Traefik, HTTPS, and hardened services"
      contains: "traefik"
    - path: "backend/.env.production.example"
      provides: "Production environment variable template"
      contains: "SENTRY_DSN"
    - path: "mobile/ios/IrisArt/PrivacyInfo.xcprivacy"
      provides: "Apple Privacy Manifest with collected data types"
      contains: "NSPrivacyCollectedDataTypes"
  key_links:
    - from: "backend/app/storage/s3.py"
      to: "backend/app/core/config.py"
      via: "CDN_BASE_URL setting for presigned URL generation"
      pattern: "CDN_BASE_URL"
    - from: "backend/docker-compose.production.yml"
      to: "backend/Dockerfile"
      via: "Docker image build for web and celery services"
      pattern: "build.*Dockerfile"
---

<objective>
Configure production deployment with Docker Compose + Traefik, set up CDN-ready image delivery, and prepare both iOS and Android apps for store submission.

Purpose: The app needs a production-ready deployment configuration, fast global image delivery via CDN, and compliance with App Store and Play Store submission requirements to launch.

Output: Production Docker Compose stack, CDN-integrated storage layer, updated Privacy Manifest, Android release config, production environment template.
</objective>

<execution_context>
@/home/jbellot/.claude/get-shit-done/workflows/execute-plan.md
@/home/jbellot/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-polish-and-production-readiness/07-RESEARCH.md
@.planning/phases/07-polish-and-production-readiness/07-01-SUMMARY.md

Key existing files:
- backend/docker-compose.yml — Dev stack (reference for production config)
- backend/Dockerfile — Multi-stage build (from 07-01)
- backend/app/core/config.py — Settings with SENTRY_DSN, ENVIRONMENT (from 07-01)
- backend/app/storage/s3.py — S3 client for MinIO (needs CDN URL support)
- mobile/ios/IrisArt/PrivacyInfo.xcprivacy — Existing privacy manifest (needs collected data types)
- mobile/android/app/build.gradle — Android build config (needs release signing)
- mobile/android/gradle.properties — Gradle config (needs build optimizations)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Production Docker Compose with Traefik and CDN-ready storage</name>
  <files>
    backend/docker-compose.production.yml
    backend/.env.production.example
    backend/app/core/config.py
    backend/app/storage/s3.py
  </files>
  <action>
    **1. Update backend/app/core/config.py:**
    Add CDN configuration to Settings class (after SENTRY_DSN and ENVIRONMENT added by 07-01):
    ```python
    # CDN
    CDN_BASE_URL: str = ""  # e.g., https://d1234.cloudfront.net — empty means direct MinIO
    ```

    **2. Update backend/app/storage/s3.py:**
    Add a method `get_public_url(key: str) -> str` that:
    - If `settings.CDN_BASE_URL` is set, returns `{CDN_BASE_URL}/{bucket}/{key}`
    - If not set, falls back to current presigned URL behavior
    - This allows mobile to receive CDN URLs for images in production while keeping presigned URLs for uploads
    - Do NOT change the existing presigned URL generation for uploads (PUT) — those must still go to MinIO
    - Only change the download/display URLs (GET) to use CDN when configured

    Also add a utility method `get_download_url(key: str, expiry: int = 3600) -> str` that:
    - Uses CDN URL if CDN_BASE_URL is configured
    - Falls back to presigned GET URL if CDN not configured
    - This is the single function all API endpoints should call for serving images to clients

    **3. Create backend/docker-compose.production.yml:**
    Production stack with Traefik reverse proxy:
    ```yaml
    services:
      traefik:
        image: traefik:v3.0
        command:
          - "--providers.docker=true"
          - "--providers.docker.exposedbydefault=false"
          - "--entrypoints.web.address=:80"
          - "--entrypoints.websecure.address=:443"
          - "--certificatesresolvers.letsencrypt.acme.httpchallenge.entrypoint=web"
          - "--certificatesresolvers.letsencrypt.acme.email=${ACME_EMAIL}"
          - "--certificatesresolvers.letsencrypt.acme.storage=/letsencrypt/acme.json"
          - "--entrypoints.web.http.redirections.entrypoint.to=websecure"
        ports:
          - "80:80"
          - "443:443"
        volumes:
          - "/var/run/docker.sock:/var/run/docker.sock:ro"
          - "letsencrypt_data:/letsencrypt"
        restart: unless-stopped

      web:
        build:
          context: .
          dockerfile: Dockerfile
        command: uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 2
        env_file: .env.production
        depends_on:
          db:
            condition: service_healthy
          redis:
            condition: service_healthy
        labels:
          - "traefik.enable=true"
          - "traefik.http.routers.web.rule=Host(`${API_DOMAIN}`)"
          - "traefik.http.routers.web.tls.certresolver=letsencrypt"
          - "traefik.http.services.web.loadbalancer.server.port=8000"
        restart: unless-stopped

      celery_worker:
        build:
          context: .
          dockerfile: Dockerfile
        command: celery -A app.workers.celery_app worker -Q high_priority,default --loglevel=warning --prefetch-multiplier=1 --concurrency=2
        env_file: .env.production
        depends_on:
          db:
            condition: service_healthy
          redis:
            condition: service_healthy
        restart: unless-stopped

      db:
        image: postgres:15
        environment:
          POSTGRES_USER: ${DB_USER}
          POSTGRES_PASSWORD: ${DB_PASSWORD}
          POSTGRES_DB: ${DB_NAME}
        volumes:
          - postgres_data:/var/lib/postgresql/data
        healthcheck:
          test: ["CMD-SHELL", "pg_isready -U ${DB_USER}"]
          interval: 10s
          timeout: 5s
          retries: 5
        restart: unless-stopped

      redis:
        image: redis:7-alpine
        command: redis-server --requirepass ${REDIS_PASSWORD}
        healthcheck:
          test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
          interval: 10s
          timeout: 5s
          retries: 5
        restart: unless-stopped

      minio:
        image: minio/minio
        command: server /data --console-address ":9001"
        environment:
          MINIO_ROOT_USER: ${MINIO_ROOT_USER}
          MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
          MINIO_SERVER_URL: https://${STORAGE_DOMAIN}
        volumes:
          - minio_data:/data
        healthcheck:
          test: ["CMD", "curl", "-f", "http://localhost:9000/minio/health/live"]
          interval: 10s
          timeout: 5s
          retries: 5
        labels:
          - "traefik.enable=true"
          - "traefik.http.routers.minio.rule=Host(`${STORAGE_DOMAIN}`)"
          - "traefik.http.routers.minio.tls.certresolver=letsencrypt"
          - "traefik.http.services.minio.loadbalancer.server.port=9000"
        restart: unless-stopped

    volumes:
      postgres_data:
      minio_data:
      letsencrypt_data:
    ```

    Key production differences from dev:
    - Traefik for HTTPS termination and routing (not direct port exposure)
    - No port exposure for db, redis (internal only)
    - Flower intentionally excluded (access via SSH tunnel in production per security best practice)
    - No volume mounts for code (uses built image)
    - `restart: unless-stopped` for all services
    - Environment variables from .env.production (not hardcoded)
    - Redis with password authentication
    - MinIO with MINIO_SERVER_URL set to public domain (fixes presigned URL hostname issue from research pitfall #5)
    - 2 uvicorn workers (can be tuned per server)
    - Celery with --loglevel=warning (not info) and --concurrency=2

    **4. Create backend/.env.production.example:**
    Template with all required production environment variables:
    ```env
    # Application
    SECRET_KEY=<generate-with-python-secrets-token-hex-32>
    ENVIRONMENT=production
    DEBUG=false

    # Database
    DATABASE_URL=postgresql+asyncpg://${DB_USER}:${DB_PASSWORD}@db:5432/${DB_NAME}
    DB_USER=irisvue
    DB_PASSWORD=<strong-random-password>
    DB_NAME=iris_art

    # Redis
    CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@redis:6379/0
    CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@redis:6379/0
    REDIS_PASSWORD=<strong-random-password>

    # Storage (MinIO)
    S3_ENDPOINT=http://minio:9000
    S3_ACCESS_KEY=<minio-access-key>
    S3_SECRET_KEY=<minio-secret-key>
    S3_BUCKET_NAME=iris-art
    MINIO_ROOT_USER=<minio-access-key>
    MINIO_ROOT_PASSWORD=<minio-secret-key>
    STORAGE_DOMAIN=storage.yourdomain.com

    # CDN (optional, for CloudFront)
    CDN_BASE_URL=https://d1234567890.cloudfront.net

    # Monitoring
    SENTRY_DSN=https://your-dsn@sentry.io/project-id

    # Deployment
    API_DOMAIN=api.yourdomain.com
    ACME_EMAIL=admin@yourdomain.com
    CORS_ORIGINS=["https://yourdomain.com"]

    # RevenueCat
    REVENUECAT_API_KEY=<from-revenuecat-dashboard>
    REVENUECAT_WEBHOOK_SECRET=<from-revenuecat-dashboard>
    ```
    This file is a TEMPLATE — it is committed to git as documentation. The actual `.env.production` is NOT committed.
  </action>
  <verify>
    - `ls backend/docker-compose.production.yml` — file exists
    - `ls backend/.env.production.example` — template exists
    - `grep "CDN_BASE_URL" backend/app/core/config.py` — CDN setting exists
    - `grep "get_download_url\|get_public_url" backend/app/storage/s3.py` — CDN-aware URL methods exist
    - `grep "traefik" backend/docker-compose.production.yml` — Traefik configured
    - `grep "SENTRY_DSN" backend/.env.production.example` — monitoring in template
    - Validate YAML: `python -c "import yaml; yaml.safe_load(open('backend/docker-compose.production.yml'))"`
  </verify>
  <done>
    - Production Docker Compose runs web, celery, postgres, redis, minio behind Traefik with HTTPS
    - CDN_BASE_URL setting enables CloudFront-served images when configured
    - S3 storage layer serves download URLs via CDN (when configured) or presigned URLs (fallback)
    - Production environment template documents all required variables
    - Flower excluded from production stack (SSH tunnel access only)
    - Redis has password authentication in production
  </done>
</task>

<task type="auto">
  <name>Task 2: App Store and Play Store submission readiness</name>
  <files>
    mobile/ios/IrisArt/PrivacyInfo.xcprivacy
    mobile/android/app/build.gradle
    mobile/android/gradle.properties
  </files>
  <action>
    **1. Update mobile/ios/IrisArt/PrivacyInfo.xcprivacy:**
    The current Privacy Manifest declares accessed API types but has empty NSPrivacyCollectedDataTypes. For App Store submission, we need to declare collected data types (Apple requires this since May 2024).

    Update NSPrivacyCollectedDataTypes to include:
    - **Photos (NSPrivacyCollectedDataTypePhotos)**: Collected, linked to user identity, for app functionality
    - **Email Address (NSPrivacyCollectedDataTypeEmailAddress)**: Collected for authentication, linked to user identity
    - **User ID (NSPrivacyCollectedDataTypeUserID)**: Collected for app functionality, linked to user identity
    - **Purchase History (NSPrivacyCollectedDataTypePurchaseHistory)**: Collected via RevenueCat, linked to user identity, for app functionality

    Keep existing NSPrivacyAccessedAPITypes (FileTimestamp, UserDefaults, SystemBootTime).
    Keep NSPrivacyTracking as false (we don't track users for advertising).

    The format for each collected data type entry:
    ```xml
    <dict>
      <key>NSPrivacyCollectedDataType</key>
      <string>{data_type}</string>
      <key>NSPrivacyCollectedDataTypeLinked</key>
      <true/>
      <key>NSPrivacyCollectedDataTypeTracking</key>
      <false/>
      <key>NSPrivacyCollectedDataTypePurposes</key>
      <array>
        <string>NSPrivacyCollectedDataTypePurposeAppFunctionality</string>
      </array>
    </dict>
    ```

    **2. Update mobile/android/app/build.gradle for release signing:**
    Read the existing build.gradle first. Then add release signing configuration:

    Add signingConfigs block inside android {} (if not already present):
    ```gradle
    signingConfigs {
        release {
            storeFile file('release.keystore')
            storePassword System.env.KEYSTORE_PASSWORD ?: ''
            keyAlias System.env.KEY_ALIAS ?: 'irisvue'
            keyPassword System.env.KEY_PASSWORD ?: ''
        }
    }
    ```

    Update buildTypes.release to use the signing config:
    ```gradle
    buildTypes {
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            signingConfig signingConfigs.release
        }
    }
    ```

    Also ensure the release build type has `minifyEnabled true` and `shrinkResources true` for code/resource shrinking (Play Store expects optimized APKs).

    **3. Update mobile/android/gradle.properties for build optimization:**
    Add production build optimizations (if not already present):
    ```properties
    # Production build optimizations
    org.gradle.jvmargs=-Xmx4096m -XX:MaxMetaspaceSize=512m
    org.gradle.parallel=true
    org.gradle.caching=true
    android.enableR8.fullMode=true
    ```
    Read existing file first and only add lines that don't already exist.
  </action>
  <verify>
    - `grep "NSPrivacyCollectedDataTypePhotos" mobile/ios/IrisArt/PrivacyInfo.xcprivacy` — Photos declared
    - `grep "NSPrivacyCollectedDataTypeEmailAddress" mobile/ios/IrisArt/PrivacyInfo.xcprivacy` — Email declared
    - `grep "signingConfigs" mobile/android/app/build.gradle` — Release signing configured
    - `grep "minifyEnabled true" mobile/android/app/build.gradle` — ProGuard enabled
    - `grep "org.gradle.caching" mobile/android/gradle.properties` — Build caching enabled
  </verify>
  <done>
    - PrivacyInfo.xcprivacy declares all collected data types (Photos, Email, User ID, Purchase History) for App Store review
    - Android release build configured with signing config (keystore from env vars for CI)
    - ProGuard/R8 minification enabled for release builds (smaller APK, code obfuscation)
    - Gradle build optimizations enabled (parallel, caching, R8 full mode)
    - App meets basic App Store and Play Store submission requirements
  </done>
</task>

</tasks>

<verification>
Phase 7 Plan 02 verification:
1. `ls backend/docker-compose.production.yml backend/.env.production.example` — Production deployment files exist
2. `grep "traefik" backend/docker-compose.production.yml` — Reverse proxy configured
3. `grep "CDN_BASE_URL" backend/app/core/config.py` — CDN setting present
4. `grep "get_download_url" backend/app/storage/s3.py` — CDN-aware download URLs
5. `grep "NSPrivacyCollectedDataTypePhotos" mobile/ios/IrisArt/PrivacyInfo.xcprivacy` — Collected data declared
6. `grep "signingConfigs" mobile/android/app/build.gradle` — Release signing
7. `grep "minifyEnabled" mobile/android/app/build.gradle` — ProGuard enabled
</verification>

<success_criteria>
- Production Docker Compose with Traefik runs the full stack behind HTTPS
- CDN configuration allows CloudFront-served images when CDN_BASE_URL is set
- PrivacyInfo.xcprivacy declares all collected data types required for App Store submission
- Android release build configured with signing and ProGuard for Play Store
- Production environment template documents every required variable for deployment
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-and-production-readiness/07-02-SUMMARY.md`
</output>
