---
phase: 05-social-features-circles-and-fusion
plan: 05
type: execute
wave: 3
depends_on: ["05-03"]
files_modified:
  - backend/app/models/fusion_artwork.py
  - backend/app/schemas/fusion.py
  - backend/app/services/fusion_service.py
  - backend/app/workers/tasks/fusion_blending.py
  - backend/app/workers/tasks/composition.py
  - backend/app/api/routes/fusion.py
  - backend/app/models/__init__.py
  - backend/app/models/user.py
  - backend/app/main.py
  - backend/alembic/versions/f6a7b8c9d0e1_add_fusion_artworks.py
autonomous: true

must_haves:
  truths:
    - "FusionArtwork model persists fusion/composition metadata including source artwork references"
    - "Poisson blending (cv2.seamlessClone with MIXED_CLONE) produces seamless iris fusion, falls back to alpha blending on error"
    - "Side-by-side composition supports 3 layouts (horizontal, vertical, grid_2x2) with dimension matching"
    - "Consent verification blocks fusion/composition until all non-self consents are granted"
    - "Fusion runs as Celery task with 3-minute timeout and WebSocket progress"
    - "Images capped at 2048x2048 to prevent memory exhaustion"
  artifacts:
    - path: "backend/app/models/fusion_artwork.py"
      provides: "FusionArtwork model tracking fusion and composition results"
      contains: "class FusionArtwork"
    - path: "backend/app/workers/tasks/fusion_blending.py"
      provides: "Celery task for Poisson blending fusion"
      contains: "create_fusion_artwork"
    - path: "backend/app/workers/tasks/composition.py"
      provides: "Side-by-side composition using OpenCV hconcat/vconcat"
      contains: "create_composition"
    - path: "backend/app/services/fusion_service.py"
      provides: "Fusion business logic with consent verification"
      contains: "submit_fusion|submit_composition"
    - path: "backend/app/api/routes/fusion.py"
      provides: "Fusion and composition REST API"
      exports: ["router"]
  key_links:
    - from: "backend/app/services/fusion_service.py"
      to: "backend/app/services/consent_service.py"
      via: "check_all_consents_granted before fusion"
      pattern: "check_all_consents_granted"
    - from: "backend/app/workers/tasks/fusion_blending.py"
      to: "cv2.seamlessClone"
      via: "Poisson blending call"
      pattern: "seamlessClone"
---

<objective>
Fusion and Composition Backend -- FusionArtwork model, Poisson blending Celery task with alpha fallback, side-by-side composition task (hconcat/vconcat), fusion service with consent verification gate, REST API, and migration.

Purpose: Deliver the core social art creation backend (SOCL-04, SOCL-05). Users combine irises into fused or composed artwork with explicit consent enforced server-side.
Output: FusionArtwork model, fusion and composition Celery tasks, REST API, Alembic migration.
</objective>

<execution_context>
@/home/jbellot/.claude/get-shit-done/workflows/execute-plan.md
@/home/jbellot/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-social-features-circles-and-fusion/05-RESEARCH.md
@.planning/phases/05-social-features-circles-and-fusion/05-01-SUMMARY.md
@.planning/phases/05-social-features-circles-and-fusion/05-03-SUMMARY.md
@.planning/phases/03-ai-processing-pipeline/03-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: FusionArtwork model, schemas, and migration</name>
  <files>
    backend/app/models/fusion_artwork.py
    backend/app/schemas/fusion.py
    backend/app/models/__init__.py
    backend/app/models/user.py
    backend/alembic/versions/f6a7b8c9d0e1_add_fusion_artworks.py
  </files>
  <action>
    **FusionArtwork Model** (`backend/app/models/fusion_artwork.py`):
    - id: UUID PK (default uuid4)
    - creator_id: UUID FK to users.id ON DELETE CASCADE, indexed
    - circle_id: UUID FK to circles.id ON DELETE SET NULL, nullable (fusion can outlive circle)
    - source_artwork_ids: JSON column (list of photo UUIDs used in fusion)
    - fusion_type: String, not null -- "fusion" (Poisson blend) or "composition" (side-by-side)
    - blend_mode: String, nullable -- "poisson", "alpha" (for fusion), or "horizontal", "vertical", "grid_2x2" (for composition)
    - status: String, default "pending" -- "pending", "processing", "completed", "failed"
    - result_s3_key: String, nullable (S3 path for completed result)
    - thumbnail_s3_key: String, nullable (S3 path for 256px preview)
    - error_message: String, nullable
    - processing_time_ms: Integer, nullable
    - created_at: DateTime(timezone=True), server_default now
    - completed_at: DateTime(timezone=True), nullable
    - Relationships: creator (User), circle (Circle, nullable)

    Update `backend/app/models/__init__.py`: Import FusionArtwork.
    Update `backend/app/models/user.py`: Add `fusion_artworks` relationship.

    **Schemas** (`backend/app/schemas/fusion.py`):
    - FusionCreateRequest: artwork_ids (List[UUID], min 2, max 4), circle_id (Optional[UUID]), blend_mode (str, default "poisson").
    - CompositionCreateRequest: artwork_ids (List[UUID], min 2, max 4), circle_id (Optional[UUID]), layout (str -- "horizontal", "vertical", "grid_2x2").
    - FusionResponse: id, creator_id, fusion_type, blend_mode, status, result_url (presigned), thumbnail_url (presigned), source_artwork_ids, created_at, completed_at.
    - FusionStatusResponse: id, status, progress (int 0-100), current_step (str), result_url, thumbnail_url.

    **Migration:**
    Generate Alembic migration creating `fusion_artworks` table with JSON column for source_artwork_ids, proper foreign keys, and indexes.
  </action>
  <verify>
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && python -c "from app.models.fusion_artwork import FusionArtwork; print('FusionArtwork OK')"`
    Verify migration file exists in alembic/versions/.
  </verify>
  <done>
    FusionArtwork model exists with fusion_type, blend_mode, JSON source_artwork_ids, and proper relationships. Schemas define request/response shapes. Migration creates fusion_artworks table.
  </done>
</task>

<task type="auto">
  <name>Task 2: Fusion/composition Celery tasks, fusion service, API routes, and router registration</name>
  <files>
    backend/app/services/fusion_service.py
    backend/app/workers/tasks/fusion_blending.py
    backend/app/workers/tasks/composition.py
    backend/app/api/routes/fusion.py
    backend/app/main.py
  </files>
  <action>
    **Fusion Blending Celery Task** (`backend/app/workers/tasks/fusion_blending.py`):
    - `create_fusion_artwork(artwork_ids: List[str], fusion_id: str, blend_mode: str = "poisson")`:
      Uses sync SQLAlchemy session (same pattern as Phase 3 processing tasks).
      1. Update FusionArtwork status to "processing" (progress 0%).
      2. Load source images from S3 (progress 10-20%). For each artwork_id, load the processed result image (result_s3_key from ProcessingJob or StyleJob -- use the best available: styled > processed). Also load segmentation masks (mask_s3_key from ProcessingJob).
      3. Resize all images to same dimensions: max 2048x2048. Use the largest source image dimensions as target (capped at 2048).
      4. Resize masks to match image dimensions.
      5. Apply Gaussian blur to mask edges (kernel=5) to smooth boundaries.
      6. Poisson blending loop (progress 30-80%): Start with first image as base. For each subsequent image, call `cv2.seamlessClone(src, dst, mask, center, cv2.MIXED_CLONE)`. If cv2.error occurs, fall back to alpha_blend_fallback.
      7. Generate thumbnail: resize result to 256x256, save as JPEG q70 to `fusion/{fusion_id}_thumb.jpg`.
      8. Save full result as JPEG q90 to `fusion/{fusion_id}.jpg` (progress 90%).
      9. Update FusionArtwork: status="completed", result_s3_key, thumbnail_s3_key, processing_time_ms, completed_at.
      10. WebSocket notification via same Celery state mechanism as Phase 3.
      - On failure: update status="failed" with error message.
      - Task config: bind=True, queue='default' (not high_priority -- fusion is less urgent), time_limit=180 (3 min max), soft_time_limit=150.
      - Memory guard: cap images at 2048x2048 to prevent OOM.

    - `alpha_blend_fallback(base, overlay, mask)`: Normalize mask to 0-1 float, expand to 3 channels if needed, blend: result = base * (1-alpha) + overlay * alpha.

    **Composition Task** (`backend/app/workers/tasks/composition.py`):
    - `create_composition(artwork_ids: List[str], fusion_id: str, layout: str = "horizontal")`:
      Uses sync SQLAlchemy session.
      1. Update FusionArtwork status to "processing".
      2. Load source images from S3 (same logic as fusion -- best available result).
      3. Determine target dimensions: for horizontal/vertical, use min height/width to avoid quality loss. For grid_2x2, use min of both.
      4. Resize all images to target dimensions.
      5. Layout:
         - "horizontal": `cv2.hconcat(images)` -- side by side
         - "vertical": `cv2.vconcat(images)` -- stacked
         - "grid_2x2": pad to 4 images with black if needed, hconcat pairs, vconcat rows
      6. Generate thumbnail (256px wide, proportional height).
      7. Save result and thumbnail to S3.
      8. Update FusionArtwork: status="completed", result_s3_key, thumbnail_s3_key, processing_time_ms.
      - Task config: queue='default', time_limit=60 (compositions are fast, <5s).

    **Fusion Service** (`backend/app/services/fusion_service.py`):
    - `submit_fusion(artwork_ids, creator_id, circle_id, blend_mode, db)`:
      1. Validate artwork_ids: 2-4 items, all photos exist and are processed (have a completed ProcessingJob or StyleJob).
      2. Check consent: call `check_all_consents_granted(artwork_ids, creator_id, "fusion", db)` from consent_service. If not all granted, return {status: "consent_required", pending: list of artwork_ids needing consent}.
      3. Create FusionArtwork record (fusion_type="fusion").
      4. Submit Celery task: `create_fusion_artwork.apply_async(args=[...], task_id=str(fusion.id))`.
      5. Return fusion record with WebSocket URL.

    - `submit_composition(artwork_ids, creator_id, circle_id, layout, db)`:
      Same as fusion but purpose="composition", fusion_type="composition". Checks consent with purpose="composition".

    - `get_fusion_status(fusion_id, user_id, db)`: Get FusionArtwork, verify creator or circle member. Return status with presigned URLs.

    - `get_user_fusions(user_id, db, offset=0, limit=20)`: List user's fusions with pagination.

    - `get_best_source_image(photo_id, db)`: Helper to find the best available processed image for a photo: first check for completed StyleJob result, then completed ProcessingJob result, then original photo. Returns S3 key.

    **API Routes** (`backend/app/api/routes/fusion.py`):
    - `POST /api/v1/fusion` -- Create fusion. Body: FusionCreateRequest. Returns FusionResponse or consent_required status.
    - `POST /api/v1/composition` -- Create composition. Body: CompositionCreateRequest. Returns FusionResponse or consent_required status.
    - `GET /api/v1/fusion/{fusion_id}` -- Fusion status with presigned URLs.
    - `GET /api/v1/fusion` -- List user's fusions. Query params: offset, limit.
    - `GET /api/v1/circles/{circle_id}/fusions` -- List fusions created in a circle context.

    Register fusion router in `backend/app/main.py`.
  </action>
  <verify>
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && python -c "from app.workers.tasks.fusion_blending import create_fusion_artwork; from app.workers.tasks.composition import create_composition; print('Tasks OK')"`
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && python -c "from app.api.routes.fusion import router; print('Fusion router OK')"`
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && python -c "from app.services.fusion_service import submit_fusion, submit_composition; print('Fusion service OK')"`
    Verify cv2.seamlessClone import: `cd /home/jbellot/Documents/repo/iris-art/backend && python -c "import cv2; print(hasattr(cv2, 'seamlessClone'))"`
  </verify>
  <done>
    Fusion Celery task performs Poisson blending with alpha fallback, 2048px cap, and mask smoothing. Composition task handles horizontal/vertical/grid_2x2 layouts. Fusion service enforces consent check before submission. API endpoints registered. All tasks have proper timeouts.
  </done>
</task>

</tasks>

<verification>
- Backend: Fusion task calls cv2.seamlessClone for Poisson blending with alpha fallback
- Backend: Composition task produces correct layouts (horizontal, vertical, grid_2x2)
- Backend: Consent gate blocks fusion/composition if any non-self artwork lacks granted consent
- Backend: FusionArtwork stores source_artwork_ids as JSON, result as S3 key
</verification>

<success_criteria>
- FusionArtwork model persists fusion/composition metadata including source artwork references
- Poisson blending (cv2.seamlessClone with MIXED_CLONE) produces seamless iris fusion, falls back to alpha blending on error
- Side-by-side composition supports 3 layouts (horizontal, vertical, grid_2x2) with dimension matching
- Consent verification blocks fusion/composition until all non-self consents are granted
- Fusion runs as Celery task with 3-minute timeout and WebSocket progress
- Images capped at 2048x2048 to prevent memory exhaustion
- Mask edges smoothed with Gaussian blur before Poisson blending
</success_criteria>

<output>
After completion, create `.planning/phases/05-social-features-circles-and-fusion/05-05-SUMMARY.md`
</output>
