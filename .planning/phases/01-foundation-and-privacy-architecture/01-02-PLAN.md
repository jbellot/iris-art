---
phase: 01-foundation-and-privacy-architecture
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - backend/app/core/security.py
  - backend/app/schemas/auth.py
  - backend/app/services/__init__.py
  - backend/app/services/auth.py
  - backend/app/api/routes/auth.py
  - backend/app/api/routes/users.py
  - backend/app/api/deps.py
  - backend/app/workers/tasks/__init__.py
  - backend/app/workers/tasks/email.py
  - backend/app/main.py
autonomous: true

must_haves:
  truths:
    - "User can sign up with email and password, receiving a JWT access token and refresh token"
    - "User can sign in with existing credentials and receive new tokens"
    - "User can refresh an expired access token using a valid refresh token"
    - "User receives email verification token after signup (via Celery task)"
    - "User can verify their email with the verification token"
    - "User can request password reset and receive reset token (via Celery task)"
    - "User can reset password with valid reset token"
    - "Apple Sign In identity token is verified server-side and creates/links user account"
    - "Google Sign In identity token is verified server-side and creates/links user account"
    - "Invalid credentials return 401, invalid tokens return 401"
  artifacts:
    - path: "backend/app/core/security.py"
      provides: "Password hashing, JWT creation/verification, OAuth2 scheme"
      contains: "create_access_token"
    - path: "backend/app/services/auth.py"
      provides: "Auth business logic (register, login, verify, reset, OAuth)"
      contains: "register_user"
    - path: "backend/app/api/routes/auth.py"
      provides: "Auth API endpoints"
      contains: "router"
    - path: "backend/app/api/routes/users.py"
      provides: "User profile and management endpoints"
      contains: "router"
    - path: "backend/app/schemas/auth.py"
      provides: "Auth request/response Pydantic models"
      contains: "TokenResponse"
    - path: "backend/app/workers/tasks/email.py"
      provides: "Email verification and password reset Celery tasks"
      contains: "send_verification_email"
    - path: "backend/app/api/deps.py"
      provides: "get_current_user dependency"
      contains: "get_current_user"
  key_links:
    - from: "backend/app/api/routes/auth.py"
      to: "backend/app/services/auth.py"
      via: "Service layer call"
      pattern: "auth_service\\."
    - from: "backend/app/services/auth.py"
      to: "backend/app/core/security.py"
      via: "Password hashing and JWT creation"
      pattern: "(create_access_token|verify_password|get_password_hash)"
    - from: "backend/app/api/deps.py"
      to: "backend/app/core/security.py"
      via: "JWT token decode for current user"
      pattern: "jwt\\.decode"
    - from: "backend/app/services/auth.py"
      to: "backend/app/workers/tasks/email.py"
      via: "Celery task dispatch for verification/reset emails"
      pattern: "send_verification_email\\.delay|send_password_reset_email\\.delay"
    - from: "backend/app/services/auth.py"
      to: "Redis"
      via: "Refresh token storage and revocation"
      pattern: "redis_client\\.(setex|exists|delete)"
---

<objective>
Implement complete authentication: email/password signup with email verification, password reset, Apple Sign In, Google Sign In, JWT access/refresh token pairs with Redis-backed revocation, and protected user endpoints.

Purpose: Authentication is required before any user-facing feature. Plan 03 (privacy) needs authenticated users to record consent. Phase 2+ needs auth for all API interactions.

Output: Working auth API endpoints where users can register, verify email, login, refresh tokens, reset password, and sign in with Apple/Google. All auth state persisted in PostgreSQL (users) and Redis (refresh tokens).
</objective>

<execution_context>
@/home/jbellot/.claude/get-shit-done/workflows/execute-plan.md
@/home/jbellot/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-privacy-architecture/01-RESEARCH.md
@.planning/phases/01-foundation-and-privacy-architecture/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Security utilities, auth schemas, and auth service layer</name>
  <files>
    backend/app/core/security.py
    backend/app/schemas/auth.py
    backend/app/services/auth.py
    backend/app/api/deps.py
    backend/app/workers/tasks/email.py
  </files>
  <action>
    **backend/app/core/security.py:** Core security utilities:
    - `password_hash = PasswordHash.recommended()` using pwdlib with Argon2
    - `verify_password(plain, hashed) -> bool`
    - `get_password_hash(password) -> str`
    - `create_access_token(data: dict, expires_delta: timedelta | None) -> str` using PyJWT with HS256, exp claim, sub claim for user_id
    - `create_refresh_token(user_id: str) -> str` -- creates JWT with type=refresh, stores in Redis with key `refresh_token:{user_id}:{token_hash}`, TTL = REFRESH_TOKEN_EXPIRE_DAYS
    - `verify_refresh_token(token: str) -> str` -- decodes JWT, checks Redis for validity, returns user_id
    - `revoke_refresh_token(user_id: str, token: str)` -- deletes from Redis
    - `revoke_all_user_tokens(user_id: str)` -- deletes all refresh tokens for user (for logout-all, account deletion)
    - `generate_verification_token(email: str) -> str` using itsdangerous URLSafeTimedSerializer
    - `verify_verification_token(token: str, max_age: int = 3600) -> str` returns email
    - `generate_password_reset_token(email: str) -> str` using itsdangerous with different salt
    - `verify_password_reset_token(token: str, max_age: int = 3600) -> str` returns email
    - OAuth2PasswordBearer scheme with tokenUrl="/api/v1/auth/login"
    - Redis client initialized from settings (use redis.asyncio.Redis for async operations)
    Use async Redis (redis.asyncio) not sync redis. Import settings from core.config.

    **backend/app/schemas/auth.py:** Pydantic models:
    - RegisterRequest(email: EmailStr, password: str) with password validator (min 8 chars, at least 1 uppercase, 1 lowercase, 1 digit)
    - LoginRequest(email: EmailStr, password: str)
    - TokenResponse(access_token: str, refresh_token: str, token_type: str = "bearer")
    - RefreshRequest(refresh_token: str)
    - VerifyEmailRequest(token: str)
    - PasswordResetRequest(email: EmailStr)
    - PasswordResetConfirm(token: str, new_password: str) with same password validator
    - AppleSignInRequest(identity_token: str, authorization_code: str | None = None)
    - GoogleSignInRequest(id_token: str)
    - MessageResponse(message: str)

    **backend/app/services/auth.py:** Auth business logic (AuthService class or module functions):
    - `register_user(db, email, password) -> User` -- checks email uniqueness, hashes password, creates user, dispatches send_verification_email.delay(email, token)
    - `authenticate_user(db, email, password) -> User | None` -- finds user by email, verifies password
    - `login_user(db, email, password) -> TokenResponse` -- authenticates, creates access + refresh tokens
    - `refresh_tokens(refresh_token) -> TokenResponse` -- verifies refresh token, creates new access token (optionally rotate refresh token)
    - `verify_email(db, token) -> User` -- verifies token, sets user.is_verified = True
    - `request_password_reset(db, email)` -- generates reset token, dispatches send_password_reset_email.delay(email, token). Do NOT reveal whether email exists (security: prevents email enumeration)
    - `reset_password(db, token, new_password)` -- verifies token, updates password hash, revokes all refresh tokens
    - `apple_sign_in(db, identity_token) -> TokenResponse` -- verifies Apple identity token using Apple's public keys (fetch from https://appleid.apple.com/auth/keys, cache with httpx), extracts sub and email, creates or links user, returns tokens. Handle "Hide My Email" case (email may be None on subsequent logins -- use auth_provider_id as stable identifier)
    - `google_sign_in(db, id_token) -> TokenResponse` -- verifies Google ID token using Google's public keys (https://www.googleapis.com/oauth2/v3/certs), extracts sub and email, creates or links user, returns tokens
    - `logout_user(user_id, refresh_token)` -- revokes the specific refresh token

    For Apple/Google verification: use PyJWT to decode the identity token, fetch the provider's public keys (JWKs), find matching kid, convert JWK to PEM with jwt.algorithms.RSAAlgorithm.from_jwk(), verify signature and claims (aud, iss, exp). Cache public keys for 24 hours using a simple in-memory dict with timestamp.

    **backend/app/api/deps.py:** Update to add:
    - `get_current_user(token, db)` -- decodes JWT access token, fetches user from DB, raises 401 if invalid/expired/user not found
    - `get_current_active_user(current_user)` -- checks is_active, raises 403 if inactive

    **backend/app/workers/tasks/email.py:** Celery email tasks:
    - `send_verification_email(email: str, token: str)` -- for now, LOG the verification link (actual email sending is an open question from research -- will use a print/log placeholder until ESP is chosen). Log format: "VERIFICATION EMAIL to {email}: http://localhost:8000/api/v1/auth/verify-email?token={token}"
    - `send_password_reset_email(email: str, token: str)` -- same pattern, LOG the reset link
    These are Celery tasks decorated with @celery_app.task. They log instead of sending real email (email provider is TBD per research open questions).

    AVOID:
    - Do NOT store refresh tokens in plain text -- store a hash of the token in Redis, compare hashes
    - Do NOT use session.query() -- use select() statements
    - Do NOT return different error messages for "user not found" vs "wrong password" (prevents email enumeration)
    - Do NOT use sync Redis client -- use redis.asyncio for consistency with async FastAPI
    - Do NOT trust Apple/Google tokens without server-side verification against their public keys
  </action>
  <verify>
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && docker compose exec web python -c "from app.core.security import create_access_token, verify_password, get_password_hash; print('Security OK')"` should succeed.
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && docker compose exec web python -c "from app.services.auth import register_user, login_user; print('Auth service OK')"` should succeed.
    Run: `cd /home/jbellot/Documents/repo/iris-art/backend && docker compose exec web python -c "from app.schemas.auth import RegisterRequest, TokenResponse; print('Schemas OK')"` should succeed.
  </verify>
  <done>
    Security module provides password hashing (Argon2), JWT creation/verification, refresh token management (Redis), and email verification/reset tokens (itsdangerous). Auth service implements register, login, refresh, verify email, reset password, Apple Sign In, Google Sign In. Email tasks log verification/reset links. All imports resolve without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Auth API routes, user routes, and integration testing</name>
  <files>
    backend/app/api/routes/auth.py
    backend/app/api/routes/users.py
    backend/app/main.py
  </files>
  <action>
    **backend/app/api/routes/auth.py:** Auth API router (prefix="/api/v1/auth"):
    - POST /register -- accepts RegisterRequest, calls register_user, returns UserRead + 201
    - POST /login -- accepts OAuth2PasswordRequestForm (for OpenAPI compatibility) OR LoginRequest, calls login_user, returns TokenResponse
    - POST /refresh -- accepts RefreshRequest, calls refresh_tokens, returns TokenResponse
    - POST /verify-email -- accepts VerifyEmailRequest, calls verify_email, returns MessageResponse
    - POST /request-password-reset -- accepts PasswordResetRequest, calls request_password_reset, returns MessageResponse (always 200, even if email not found -- prevents enumeration)
    - POST /reset-password -- accepts PasswordResetConfirm, calls reset_password, returns MessageResponse
    - POST /apple -- accepts AppleSignInRequest, calls apple_sign_in, returns TokenResponse
    - POST /google -- accepts GoogleSignInRequest, calls google_sign_in, returns TokenResponse
    - POST /logout -- requires auth (get_current_user), accepts refresh_token in body, calls logout_user, returns MessageResponse

    **backend/app/api/routes/users.py:** User API router (prefix="/api/v1/users"):
    - GET /me -- requires auth, returns UserRead for current user
    - (Placeholder for DELETE /me -- implemented in Plan 03 with full GDPR deletion)

    **backend/app/main.py:** Update to include auth and users routers.

    After creating routes, run integration tests using the Docker stack:
    1. Start the stack: `docker compose up -d`
    2. Run any needed migration if models changed: `docker compose exec web alembic revision --autogenerate -m "auth_updates"` then `docker compose exec web alembic upgrade head`
    3. Test registration: `curl -X POST http://localhost:8000/api/v1/auth/register -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Test1234"}'` -- should return 201 with user data
    4. Check Celery logs for verification email: `docker compose logs celery_worker` -- should show the verification link
    5. Test login: `curl -X POST http://localhost:8000/api/v1/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"Test1234"}'` -- should return access_token and refresh_token
    6. Test /me with token: `curl http://localhost:8000/api/v1/users/me -H "Authorization: Bearer {access_token}"` -- should return user data
    7. Test refresh: `curl -X POST http://localhost:8000/api/v1/auth/refresh -H "Content-Type: application/json" -d '{"refresh_token":"{refresh_token}"}'` -- should return new tokens
    8. Test invalid login: `curl -X POST http://localhost:8000/api/v1/auth/login -H "Content-Type: application/json" -d '{"email":"test@example.com","password":"wrong"}'` -- should return 401
    9. Test password reset request: `curl -X POST http://localhost:8000/api/v1/auth/request-password-reset -H "Content-Type: application/json" -d '{"email":"test@example.com"}'` -- should return 200
    10. Test logout: `curl -X POST http://localhost:8000/api/v1/auth/logout -H "Authorization: Bearer {access_token}" -H "Content-Type: application/json" -d '{"refresh_token":"{refresh_token}"}'` -- should return 200
    11. Verify OpenAPI docs accessible: `curl http://localhost:8000/docs` -- should return HTML

    If any test fails, fix the issue before proceeding.

    AVOID:
    - Do NOT use form data for register/login body (use JSON) -- OAuth2PasswordRequestForm is for OpenAPI docs compatibility only, provide both options
    - Do NOT return user password hash in any response
    - Do NOT allow login without checking is_active
  </action>
  <verify>
    Run full integration test sequence (register -> login -> /me -> refresh -> logout) via curl against running Docker stack. All steps return expected status codes (201 for register, 200 for login/refresh/logout, 401 for invalid credentials).
    Run: `curl http://localhost:8000/docs` returns OpenAPI UI HTML.
    Run: `docker compose logs celery_worker | grep VERIFICATION` shows email task executed.
  </verify>
  <done>
    All auth endpoints work: register (201 + user data), login (200 + tokens), refresh (200 + new tokens), verify-email (200), request-password-reset (200), reset-password (200), apple sign-in endpoint exists, google sign-in endpoint exists, logout (200 + token revoked), /me (200 + user data with valid token, 401 without). Celery worker processes email tasks. OpenAPI docs show all endpoints.
  </done>
</task>

</tasks>

<verification>
1. POST /api/v1/auth/register with valid email/password returns 201 and user data
2. POST /api/v1/auth/login with valid credentials returns 200 with access_token and refresh_token
3. GET /api/v1/users/me with valid Bearer token returns 200 with user profile
4. POST /api/v1/auth/refresh with valid refresh_token returns 200 with new tokens
5. POST /api/v1/auth/login with wrong password returns 401
6. GET /api/v1/users/me without token returns 401
7. POST /api/v1/auth/logout revokes refresh token (subsequent refresh fails)
8. POST /api/v1/auth/register with duplicate email returns 409
9. Celery worker logs show verification email dispatched after registration
10. Password reset flow: request -> check logs for token -> reset with token -> login with new password
</verification>

<success_criteria>
- User can register with email/password and receive JWT tokens
- User can login and access protected endpoints with Bearer token
- Refresh tokens are stored in Redis and can be revoked
- Email verification and password reset tokens work (logged, not actually sent)
- Apple and Google Sign In endpoints exist and accept identity tokens
- Invalid credentials consistently return 401 without leaking user existence
- OpenAPI docs show all auth endpoints with request/response schemas
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-privacy-architecture/01-02-SUMMARY.md`
</output>
