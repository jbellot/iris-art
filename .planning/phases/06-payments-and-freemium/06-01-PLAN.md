---
phase: 06-payments-and-freemium
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models/purchase.py
  - backend/app/models/webhook_event.py
  - backend/app/schemas/purchases.py
  - backend/app/services/purchases.py
  - backend/app/services/rate_limiting.py
  - backend/app/api/routes/webhooks.py
  - backend/app/api/routes/purchases.py
  - backend/app/api/dependencies/rate_limit.py
  - backend/app/core/config.py
  - backend/app/models/__init__.py
  - backend/app/models/user.py
  - backend/app/main.py
  - backend/alembic/versions/d3e4f5a6b7c8_add_purchases_webhook_events_and_user_premium_fields.py
  - mobile/package.json
  - mobile/src/services/purchases.ts
  - mobile/src/hooks/usePurchases.ts
  - mobile/src/types/purchases.ts
  - mobile/src/components/PremiumGate.tsx
  - mobile/src/components/RateLimitBanner.tsx
autonomous: true
user_setup:
  - service: revenuecat
    why: "Cross-platform in-app purchase management"
    env_vars:
      - name: REVENUECAT_API_KEY
        source: "RevenueCat Dashboard -> Project -> API Keys -> Secret API key (for server-side verification)"
      - name: REVENUECAT_WEBHOOK_SECRET
        source: "RevenueCat Dashboard -> Project -> Integrations -> Webhooks -> Authorization Header value"
      - name: REVENUECAT_PUBLIC_API_KEY_IOS
        source: "RevenueCat Dashboard -> Project -> API Keys -> iOS public API key"
      - name: REVENUECAT_PUBLIC_API_KEY_ANDROID
        source: "RevenueCat Dashboard -> Project -> API Keys -> Android public API key"
    dashboard_config:
      - task: "Create RevenueCat project"
        location: "RevenueCat Dashboard -> Create New Project"
      - task: "Add iOS app with App Store Connect shared secret"
        location: "RevenueCat Dashboard -> Project -> Apps -> + New -> App Store"
      - task: "Add Android app with Google Play service account JSON"
        location: "RevenueCat Dashboard -> Project -> Apps -> + New -> Play Store"
      - task: "Create products: hd_export (consumable, 4.99 EUR), premium_styles (non-consumable)"
        location: "RevenueCat Dashboard -> Project -> Products"
      - task: "Create entitlement 'pro' and attach premium_styles product"
        location: "RevenueCat Dashboard -> Project -> Entitlements"
      - task: "Create offering 'default' with packages for hd_export and premium_styles"
        location: "RevenueCat Dashboard -> Project -> Offerings"
      - task: "Configure webhook URL pointing to backend /api/v1/webhooks/revenuecat"
        location: "RevenueCat Dashboard -> Project -> Integrations -> Webhooks"
  - service: app_store_connect
    why: "iOS in-app purchase product registration"
    env_vars: []
    dashboard_config:
      - task: "Create consumable IAP: com.irisvue.hd_export (4.99 EUR)"
        location: "App Store Connect -> App -> Features -> In-App Purchases"
      - task: "Create non-consumable IAP: com.irisvue.premium_styles"
        location: "App Store Connect -> App -> Features -> In-App Purchases"
  - service: google_play_console
    why: "Android in-app purchase product registration"
    env_vars: []
    dashboard_config:
      - task: "Create managed product: hd_export (4.99 EUR)"
        location: "Google Play Console -> App -> Monetize -> Products -> In-app products"
      - task: "Create managed product: premium_styles"
        location: "Google Play Console -> App -> Monetize -> Products -> In-app products"

must_haves:
  truths:
    - "Backend can receive and process RevenueCat webhook events with idempotency"
    - "Backend can verify subscriber status via RevenueCat REST API"
    - "Backend tracks purchases in database with transaction deduplication"
    - "Backend can check and enforce monthly AI generation rate limits for free users"
    - "Mobile initializes RevenueCat SDK and can query customer entitlements"
    - "Mobile can initiate purchases and handle success/cancel/error states"
  artifacts:
    - path: "backend/app/models/purchase.py"
      provides: "Purchase transaction records"
      contains: "class Purchase"
    - path: "backend/app/models/webhook_event.py"
      provides: "Webhook event deduplication"
      contains: "class WebhookEvent"
    - path: "backend/app/services/purchases.py"
      provides: "RevenueCat REST API integration"
      contains: "verify_subscriber_status"
    - path: "backend/app/services/rate_limiting.py"
      provides: "Monthly AI generation quota enforcement"
      contains: "class RateLimitService"
    - path: "backend/app/api/routes/webhooks.py"
      provides: "RevenueCat webhook receiver"
      contains: "revenuecat_webhook"
    - path: "mobile/src/hooks/usePurchases.ts"
      provides: "Purchase flow hook for mobile"
      exports: ["usePurchases"]
    - path: "mobile/src/services/purchases.ts"
      provides: "RevenueCat SDK wrapper"
      exports: ["initializePurchases", "purchaseHDExport", "purchasePremiumStyles"]
  key_links:
    - from: "backend/app/api/routes/webhooks.py"
      to: "backend/app/services/purchases.py"
      via: "webhook handler calls verify_subscriber_status and handle_purchase_event"
      pattern: "verify_subscriber_status|handle_purchase_event"
    - from: "backend/app/api/routes/webhooks.py"
      to: "backend/app/models/webhook_event.py"
      via: "idempotency check before processing"
      pattern: "WebhookEvent.*event_id"
    - from: "mobile/src/hooks/usePurchases.ts"
      to: "mobile/src/services/purchases.ts"
      via: "hook wraps SDK calls"
      pattern: "import.*purchases"
---

<objective>
RevenueCat integration for cross-platform in-app purchases with server-side verification

Purpose: Establish the payment infrastructure -- Purchase/WebhookEvent models, RevenueCat webhook receiver with idempotency, subscriber verification service, rate limiting service, and mobile SDK initialization with purchase hooks. This is the foundation that Plan 06-02 wires into existing features.

Output: Backend payment models + webhook endpoint + purchase/rate-limit services, mobile RevenueCat SDK + usePurchases hook + reusable UI components (PremiumGate, RateLimitBanner)
</objective>

<execution_context>
@/home/jbellot/.claude/get-shit-done/workflows/execute-plan.md
@/home/jbellot/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-payments-and-freemium/06-RESEARCH.md
@.planning/phases/04-camera-guidance-and-artistic-styles/04-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Backend payment infrastructure -- models, services, webhook, rate limiting</name>
  <files>
    backend/app/models/purchase.py
    backend/app/models/webhook_event.py
    backend/app/schemas/purchases.py
    backend/app/services/purchases.py
    backend/app/services/rate_limiting.py
    backend/app/api/routes/webhooks.py
    backend/app/api/routes/purchases.py
    backend/app/api/dependencies/rate_limit.py
    backend/app/core/config.py
    backend/app/models/__init__.py
    backend/app/models/user.py
    backend/app/main.py
    backend/alembic/versions/d3e4f5a6b7c8_add_purchases_webhook_events_and_user_premium_fields.py
  </files>
  <action>
    **1. Purchase model** (`backend/app/models/purchase.py`):
    - Create `Purchase(Base)` with fields: id (UUID PK), user_id (FK users.id), product_id (str), transaction_id (str unique index), purchase_type (enum: consumable, non_consumable), amount (Float), currency (str default "EUR"), revenuecat_event_id (str nullable), created_at (datetime). Add relationship to User.

    **2. WebhookEvent model** (`backend/app/models/webhook_event.py`):
    - Create `WebhookEvent(Base)` with fields: id (UUID PK), event_id (str unique index -- RevenueCat event ID for idempotency), event_type (str), app_user_id (str), payload (JSON), processed_at (datetime default utcnow), created_at (datetime).

    **3. User model updates** (`backend/app/models/user.py`):
    - Add fields: `is_premium` (Boolean default False), `monthly_ai_count` (Integer default 0), `last_reset_month` (String nullable -- "YYYY-MM" format). Add `purchases` relationship.

    **4. Update models/__init__.py** to import Purchase and WebhookEvent.

    **5. Alembic migration**: Add purchases table, webhook_events table, and three new columns to users (is_premium, monthly_ai_count, last_reset_month). Use `op.add_column` for user fields.

    **6. Config updates** (`backend/app/core/config.py`):
    - Add settings: REVENUECAT_API_KEY (str default ""), REVENUECAT_WEBHOOK_SECRET (str default ""), REVENUECAT_PUBLIC_API_KEY_IOS (str default ""), REVENUECAT_PUBLIC_API_KEY_ANDROID (str default "").

    **7. Purchase schemas** (`backend/app/schemas/purchases.py`):
    - PurchaseResponse: id, user_id, product_id, transaction_id, purchase_type, amount, currency, created_at
    - HDExportPurchaseRequest: export_job_id (UUID)
    - RateLimitStatusResponse: current_usage (int), limit (int), reset_date (str), is_premium (bool)
    - SubscriberStatusResponse: is_premium (bool), entitlements (list[str]), has_active_subscription (bool)

    **8. Purchase service** (`backend/app/services/purchases.py`):
    - `verify_subscriber_status(revenuecat_user_id: str) -> dict`: GET https://api.revenuecat.com/v1/subscribers/{id} with Bearer auth header. Use httpx async client (already in project). Return subscriber JSON.
    - `check_entitlement(user_id: str, entitlement_id: str) -> bool`: Call verify_subscriber_status, check entitlements dict for active entitlement.
    - `handle_consumable_purchase(db, user_id, event, subscriber_data)`: Record Purchase, find most recent unpaid pending/processing ExportJob for user, set is_paid=True. Idempotent on transaction_id.
    - `handle_non_consumable_purchase(db, user_id, event, subscriber_data)`: Record Purchase, set user.is_premium=True.
    - `handle_purchase_event(db, event_type, app_user_id, event, subscriber_data)`: Route to consumable/non-consumable handler based on event_type. Handle: NON_RENEWING_PURCHASE (consumable HD export), INITIAL_PURCHASE (premium styles unlock), EXPIRATION (set is_premium=False).

    **9. Rate limiting service** (`backend/app/services/rate_limiting.py`):
    - `class RateLimitService` with methods:
      - `check_rate_limit(db, user: User, limit: int = 3) -> tuple[bool, int, int]`: Check user.monthly_ai_count against limit. If user.last_reset_month != current "YYYY-MM", reset count to 0. Return (is_allowed, current_count, limit).
      - `increment_usage(db, user: User) -> int`: Increment user.monthly_ai_count, set last_reset_month to current month, commit. Return new count.
      - `get_reset_date() -> datetime`: First day of next month.
      - `get_status(db, user: User) -> dict`: Return current_usage, limit, reset_date, is_premium.
    - Use database fields (not Redis) as source of truth for rate limits per research recommendation. Redis is NOT needed here -- monthly counts are low-frequency and database is authoritative.

    **10. Rate limit dependency** (`backend/app/api/dependencies/rate_limit.py`):
    - `check_ai_generation_limit(user, db)`: FastAPI dependency. If user.is_premium, pass through. Otherwise check RateLimitService.check_rate_limit. Raise HTTPException 429 with detail containing message, current_usage, limit, reset_date, upgrade_available if limit exceeded. Return user if allowed.

    **11. Webhook endpoint** (`backend/app/api/routes/webhooks.py`):
    - POST /api/v1/webhooks/revenuecat: Verify Authorization header against REVENUECAT_WEBHOOK_SECRET. Parse event body (id, type, app_user_id). Check WebhookEvent table for duplicate event_id (idempotency). If new: insert WebhookEvent, fetch subscriber data via verify_subscriber_status, call handle_purchase_event, commit. Always return 200 (even on processing errors -- log errors but don't trigger webhook retries for permanent failures).

    **12. Purchase endpoint** (`backend/app/api/routes/purchases.py`):
    - GET /api/v1/purchases/rate-limit-status: Return rate limit status for current user (current_usage, limit, reset_date, is_premium).
    - GET /api/v1/purchases/subscriber-status: Call verify_subscriber_status for current user, return entitlement info.

    **13. Register routes** in `backend/app/main.py`: Import and include webhooks router and purchases router.

    Do NOT use fastapi-limiter or slowapi -- the research recommended them but the actual implementation is simpler: database-backed monthly counters on the User model, checked via FastAPI dependency. This avoids adding unnecessary dependencies.
  </action>
  <verify>
    - `python -c "from app.models.purchase import Purchase; from app.models.webhook_event import WebhookEvent; print('Models OK')"` succeeds
    - `python -c "from app.services.purchases import verify_subscriber_status, handle_purchase_event; print('Service OK')"` succeeds
    - `python -c "from app.services.rate_limiting import RateLimitService; print('RateLimit OK')"` succeeds
    - `python -c "from app.api.routes.webhooks import router; print('Webhook router OK')"` succeeds
    - `python -c "from app.api.routes.purchases import router; print('Purchase router OK')"` succeeds
    - `python -c "from app.api.dependencies.rate_limit import check_ai_generation_limit; print('Dependency OK')"` succeeds
    - Alembic migration file exists and contains purchases table, webhook_events table, and user column additions
  </verify>
  <done>
    Purchase and WebhookEvent models exist with proper relationships. RevenueCat webhook endpoint receives events with idempotency (duplicate event_id returns 200 without reprocessing). Purchase service verifies subscriber status via REST API and routes events to appropriate handlers. Rate limiting service tracks monthly AI generation count on User model with automatic month reset. Rate limit FastAPI dependency raises 429 for free users exceeding 3/month with reset date and upgrade messaging. Config has RevenueCat API keys. All routes registered in main.py.
  </done>
</task>

<task type="auto">
  <name>Task 2: Mobile RevenueCat SDK, purchase hooks, and reusable payment UI components</name>
  <files>
    mobile/package.json
    mobile/src/services/purchases.ts
    mobile/src/hooks/usePurchases.ts
    mobile/src/types/purchases.ts
    mobile/src/components/PremiumGate.tsx
    mobile/src/components/RateLimitBanner.tsx
  </files>
  <action>
    **1. Install react-native-purchases** (`mobile/package.json`):
    - Run `cd mobile && npm install --save react-native-purchases@9.7.6`

    **2. Purchase types** (`mobile/src/types/purchases.ts`):
    - `PurchaseProduct`: id, identifier, price, priceString, currencyCode, title, description
    - `CustomerEntitlement`: identifier, isActive, expirationDate (nullable)
    - `PurchaseState`: isPremium (bool), isLoading (bool), customerInfo (nullable), offerings (nullable)
    - `RateLimitStatus`: current_usage (number), limit (number), reset_date (string), is_premium (boolean)

    **3. Purchase service** (`mobile/src/services/purchases.ts`):
    - `initializePurchases(userId: string)`: Configure Purchases SDK with platform-specific API key (Platform.select ios/android). Call Purchases.logIn(userId) to identify user. Wrap in try/catch, log errors but don't crash (purchases should degrade gracefully).
    - `getOfferings()`: Return Purchases.getOfferings() -- available packages for purchase.
    - `purchaseHDExport(exportJobId: string)`: Get offerings, find 'hd_export' package, call Purchases.purchasePackage. On success, POST to /api/v1/purchases/hd-export with transaction info and export_job_id. Return purchase result.
    - `purchasePremiumStyles()`: Get offerings, find 'premium_styles' package, call Purchases.purchasePackage. Return purchase result.
    - `restorePurchases()`: Call Purchases.restorePurchases(). Return restored customer info.
    - `getCustomerInfo()`: Return Purchases.getCustomerInfo(). Check entitlements.active['pro'] for premium status.
    - `getRateLimitStatus()`: GET /api/v1/purchases/rate-limit-status from backend API. Return RateLimitStatus.
    - Export API key constants from @env (REVENUECAT_PUBLIC_API_KEY_IOS, REVENUECAT_PUBLIC_API_KEY_ANDROID). Use empty string fallbacks for dev mode -- SDK init silently fails if key is empty, allowing app to run without RevenueCat configured.

    **4. usePurchases hook** (`mobile/src/hooks/usePurchases.ts`):
    - State: customerInfo (CustomerInfo | null), isLoading (bool), isPremium (bool derived from customerInfo entitlements)
    - On mount: call getCustomerInfo(), set state. Add Purchases.addCustomerInfoUpdateListener to react to purchase changes in real-time.
    - `purchasePackage(pkg)`: Wrap Purchases.purchasePackage, update customerInfo on success. Catch userCancelled separately (not an error).
    - `restorePurchases()`: Call restorePurchases service, update customerInfo.
    - `refresh()`: Re-fetch customerInfo.
    - Return: { customerInfo, isLoading, isPremium, purchasePackage, restorePurchases, refresh }
    - Handle SDK not configured gracefully: if Purchases.getCustomerInfo() throws, set isPremium=false and isLoading=false (dev mode works without RevenueCat).

    **5. PremiumGate component** (`mobile/src/components/PremiumGate.tsx`):
    - Props: feature (string), onUpgrade (() => void), children (ReactNode)
    - Uses usePurchases() hook to check isPremium.
    - If premium: render children directly.
    - If not premium: render locked overlay with lock icon (use text emoji as placeholder), feature title, "Unlock {feature} with Premium" description, "See Premium Plans" button calling onUpgrade. Children rendered at 30% opacity behind the overlay.
    - Style: match existing app color scheme (purple #7C3AED primary, gray secondary).

    **6. RateLimitBanner component** (`mobile/src/components/RateLimitBanner.tsx`):
    - Props: currentUsage (number), limit (number), resetDate (string), onUpgrade (() => void)
    - If currentUsage < limit: show subtle info banner "You have {remaining} free AI generations this month"
    - If currentUsage >= limit: show warning banner "Monthly limit reached. Resets {formatted resetDate}. Upgrade for unlimited." with upgrade button.
    - Style: info = light blue background, warning = amber/yellow background. Compact horizontal layout.
  </action>
  <verify>
    - `cd mobile && node -e "const pkg = require('./package.json'); console.log(pkg.dependencies['react-native-purchases'])"` outputs "9.7.6" or "^9.7.6"
    - `cd mobile && node -e "require('./src/types/purchases.ts')"` does not error (via ts-node or tsconfig check)
    - Files exist: mobile/src/services/purchases.ts, mobile/src/hooks/usePurchases.ts, mobile/src/components/PremiumGate.tsx, mobile/src/components/RateLimitBanner.tsx
    - TypeScript types correctly exported from purchases.ts
  </verify>
  <done>
    react-native-purchases@9.7.6 installed. Purchase service wraps SDK with platform-specific initialization, HD export purchase flow, premium styles purchase, and restore purchases. usePurchases hook provides isPremium state with real-time updates via listener. PremiumGate component conditionally renders locked overlay for non-premium users. RateLimitBanner shows remaining quota or limit-reached messaging. All components degrade gracefully when RevenueCat is not configured (dev mode).
  </done>
</task>

</tasks>

<verification>
- Backend: Purchase and WebhookEvent models importable, webhook endpoint registered at /api/v1/webhooks/revenuecat, purchase routes at /api/v1/purchases/*, rate limit dependency importable
- Mobile: react-native-purchases installed, purchase service and hook created, PremiumGate and RateLimitBanner components exist
- Alembic migration adds purchases table, webhook_events table, and is_premium/monthly_ai_count/last_reset_month columns to users
- Config has all 4 RevenueCat settings with empty string defaults (dev-safe)
</verification>

<success_criteria>
- All Python imports succeed without errors
- All TypeScript files created with proper exports
- react-native-purchases@9.7.6 in package.json dependencies
- Webhook endpoint handles duplicate events idempotently
- Rate limit service correctly tracks monthly counts with month auto-reset
- Mobile usePurchases hook degrades gracefully without RevenueCat configuration
</success_criteria>

<output>
After completion, create `.planning/phases/06-payments-and-freemium/06-01-SUMMARY.md`
</output>
